---
layout: default
title: VCube Versão 2
---

<body>
    <a href="../">Voltar</a>
    <h1>VCube Versão 2</h1>
    <p>Página dedicada à versão 2 do algoritmo de sistemas distribuídos VCube.</p>
    <h2>Código</h2>
    <p>Fontes: <a href="./src/vcube2.c">vcube2.c</a> <a href="./src/vcube2.h">vcube2.h</a></p></p>
    <p>O código foi escrito a partir do código do <a href="../vcube1/src/vcube1.c">vcube1.c</a> da <a
            href="../vcube1/">Versão 1</a> do <a href="../">Trabalho Prático 2</a>. As seguintes alterações foram realizadas
        para cumprir os requisitos do Trabalho Prático 2:</p>
        <ol>
            <li>Remoção da propriedade do cluster a ser testado por cada processo e todas as suas referências no restante do código:</li>
{% highlight c %}
// Descritor do processo
typedef struct {
    int id;      // identificador de facility do SMPL
    int *state;  // vetor de estados de cada processo
    bool tested; // se o processo testou na rodada atual
} ProcessType;
{% endhighlight %}
            <li>O caso de teste foi modificado para que cada processo teste todos os clusters a cada rodada e verificar se cada
                processo do cluster deve ser testado ou não:</li>
{% highlight c %}
case TEST:
    if (status(process[token].id) != 0)
        break; // se processo falho, nao testa
    printf("\n==========================================\n");
    printf("Iniciando testes do processo %d\n", token);
    print_state(N, token);
    // testa todos os clusters a cada rodada
    for (int s = 1; s <= logN; ++s) {
        nodes = cis(token, s);
        print_cluster(nodes->nodes, s, nodes->size);
        for (int j = 0; j < nodes->size; ++j) {
            if (nodes->nodes[j] >= N) {
                continue;
            }
            // verifica se é testador para cada processo do cluster
            token2 = verify_tester(j, s, token, nodes->nodes);
            if (token2 != -1) {
                t = status(process[token2].id);
                t_result = t % 2 == 0 ? "correto" : "falho";
                printf("Processo %d testou processo %d no tempo %4.1f: %s\n", token,
                        token2, time(), t_result);
                if ((t == 0 && process[token].state[token2] % 2 != 0) ||
                    (t == 1 && process[token].state[token2] % 2 != 1)) {
                    if (process[token].state[token2] == -1) {
                        process[token].state[token2] = t;
                    } else {
                        ++process[token].state[token2];
                    }
                    printf("State[%d] atualizado para %d\n", token2,
                            process[token].state[token2]);
                    count_event_test(N, token, token2);
                    count_event_discovery(N, token, token2,
                                            process[token].state[token2]);
                }
                if (t % 2 == 0) { // se par esta sem falha, verifica novidades
                    check_state(N, token, token2);
                }
            }
        }
        set_free(nodes);
    }
    schedule(TEST, 30.0, token);
    print_state(N, token);
    process[token].tested = true;
    printf("==========================================\n");
    break;
{% endhighlight %}
            <li>Uma função para verificar se um processo deve ser testado em determinado cluster:</li>
{% highlight c %}
int to_test = -1;
node_set *nodes_j = cis(j, s);
for (int k = 0; k < nodes_j->size; ++k) {
    if (process[token].state[nodes_j->nodes[k]] % 2 == 0) {
        if (nodes_j->nodes[k] == token) {
            to_test = nodes[j];
        }
        break;
    }
}
set_free(nodes_j);
return to_test;
{% endhighlight %}
            <li>A função para transferência de estados foi adaptada para o VCube (versão 2). Agora são transferidas quaisquer
                novidades que o processo encontrar sobre todos os outros processos:</li>
{% highlight c %}
for (int i = 0; i < N; ++i) {
    if (i == token)
        continue;
    if (process[token2].state[i] > process[token].state[i]) {
        transfered = true;
        printf("Novidade encontrada, transferindo state[%d]...\n", i);
        printf("State[%d] atualizado para %d\n", i, process[token2].state[i]);
        process[token].state[i] = process[token2].state[i];
        count_event_discovery(N, token, i, process[token2].state[i]);
    }
}
{% endhighlight %}
        </ol>
</body>