---
layout: default
title: Trabalho Prático 1
---

<body>
    <h1>Trabalho Prático 1</h1>
    <p><b>Especificação:</b> Implemente o algoritmo VRing no ambiente de simulação SMPL, e mostre resultados para diversos
        valores de N e diversos eventos - um evento em um processo de cada vez, um evento só ocorre depois do evento
        anterior ser diagnosticado. Para cada evento mostre claramente o número de testes executados e a latência para
        completar o diagnóstico do evento. Cada nodo mantém o vetor STATE[0..N-1] de contadores de eventos, inicializado em
        -1 (estado “unknown”). Assume-se que os processos são inicializados sem-falha, a entrada correspondente ao próprio
        processo no vetor STATE[] do testador é setada para zero. Ao descobrir um novo evento em um nodo testado, o testador
        incrementa a entrada correspondente no vetor STATE[].</p>
    <p>Para a transferência de informações de diagnóstico lembre-se da estratégia do VRing: quando um processo sem-falha
        testa outro processo sem-falha obtém informações sobre os estados de todos os processos que não testou no intervalo
        de testes corrente. É importante comparar as entradas correspondentes dos vetores STATE (testador e testado) para
        saber se o testado tem alguma novidade. Se o valor da entrada for maior no vetor STATE do processo testado, então
        copia a informação.</p>

    <h2>Código</h2>
    <p>Fontes: <a href="./src/vring.c">vring.c</a> <a href="./src/vring.h">vring.h</a></p></p>
    <p>O código foi escrito a partir do código da <a href="../trab0/src/tarefa4.c">tarefa4.c</a> do <a
            href="../trab0/index.html">Trabalho Prático 0</a>. As seguintes alterações foram realizadas para cumprir os
        requisitos do Trabalho Prático 1:</p>
    <ol>
        <li>Uma estrutura de dados para guardar as propriedades de cada evento:</li>
{% highlight c %}
// Descritor do evento
typedef struct {
    int id;        // identificador do evento
    int e_round;   // round em que o evento ocorreu
    double e_time; // tempo em que o evento ocorreu
    int proc;      // numero do processo de origem
    int type;      // tipo do evento: 0 = recuperacao, 1 = falha
    int n_tests;   // numero de testes do evento
    bool diag;     // se o evento ja foi diagnosticado
    int latency;   // latencia para diagnosticar o evento
} Event;
{% endhighlight %}
        <li>Inclusão de uma biblioteca própria de lista (<a href="../lib/array.c">array.c</a>,<a href="../lib/array.h">array.h</a>) para guardar todos os eventos
            durante a simulação.</li>
        <li>Funções auxiliares para a simulação que estão descritas no <a href="./src/vring.h">vring.h</a></li>
        <li>
            O caso de teste foi modificado para trabalhar com estados pares (corretos) e ímpares (falhos), além de contabilizar
            as métricas dos eventos:
        </li>
{% highlight c %}
case TEST:
    if (status(process[token].id) != 0)
    break; // se processo falho, nao testa
    token2 = token;
    printf("\n==========================================\n");
    printf("Iniciando testes do processo %d\n", token);
    print_state(N, token);
    do {
    token2 = (token2 + 1) % N;
    if (token2 == token) {
        printf("Todos os demais processos estao falhos!\n");
        break;
    }
    t = status(process[token2].id);
    t_result = t % 2 == 0 ? "correto" : "falho";
    printf("Processo %d testou processo %d no tempo %4.1f: %s\n", token,
            token2, time(), t_result);
    if (t == 0 && process[token].state[token2] % 2 != 0 ||
        t == 1 && process[token].state[token2] % 2 != 1) {
        ++process[token].state[token2];
        printf("State[%d] atualizado para %d\n", token2,
                process[token].state[token2]);
        count_event_test(N, token, token2);
        count_event_discovery(N, token, token2);
    }
    if (t % 2 == 0) { // se par esta sem falha, verifica novidades
        check_state(N, token, token2);
    }
    } while (t != 0);
    schedule(TEST, 30.0, token);
    print_state(N, token);
    printf("==========================================\n");
    break;
{% endhighlight %}
        <li>A função de transferência de estados agora verifica se o processo testado correto possui novidades para efetuar a
            transferência:</li>
{% highlight c %}
for (int i = (token2 + 1) % N;; i = (i + 1) % N) {
    if (i == token)
        break;
    if (process[token2].state[i] > process[token].state[i]) {
        transfered = true;
        printf("Novidade encontrada, transferindo state[%d]...\n", i);
        printf("State[%d] atualizado para %d\n", i, process[token2].state[i]);
        process[token].state[i] = process[token2].state[i];
        count_event_discovery(N, token, i);
    }
}
{% endhighlight %}
        <li>Assim que um evento é descoberto por um processo (por meio de testes ou transferências), a função verifica se todos
            os processos já descobriram aquele evento para efetivar o seu diagnóstico:</li>
{% highlight c %}
if (event != NULL && event->latency == 0 && event->proc == token2) {
    printf("Event[%d] descoberto pelo processo %d\n", event->id, token);
    // checa se todos os processos sem falha descobriram o evento
    bool diag = true;
    for (int i = 0; i < N; ++i) {
        if (process[i].state[token2] != -1 &&
            process[i].state[token2] != process[token2].state[token2]) {
        diag = false;
        break;
        }
    }
    if (diag) {
        printf("--> Diagnostico do evento %d completo\n", event->id);
        event->diag = true;
        event->latency = sim_round - event->e_round;
    }
}
{% endhighlight %}
        <li>Uma verificação para garantir que o próximo evento (tanto falha quanto recuperação) só seja disparado quando o anterior for diagnosticado foi
            incluída para garantir a estabilidade do programa, que não funciona com eventos simultâneos:</li>
{% highlight c %}
// se o evento anterior nao foi diagnosticado ainda, adia o evento para a
// proxima rodada
if (event != NULL && !event->diag) {
    delay_event(FAULT, token);
    break;
}
{% endhighlight %}
        <li>Uma função para criação do evento (falha ou recuperação), onde para falhas o vetor de estados do processo em que o
            evento ocorre é reinicializado. O próprio estado do processo é utilizado para verificação do diagnóstico. Ele não é
            utilizado para transferências:</li>
        {% highlight c %}
        event = (Event *)malloc(sizeof(Event));
        event->id = ++id_cont;
        event->e_round = sim_round;
        event->e_time = time();
        event->proc = token;
        event->type = type;
        event->n_tests = 0;
        event->diag = false;
        event->latency = 0;
        insert_array(event_array, event);
        
        // se falha, reseta o vetor de estados pois é falha crash
        if (type == 1) {
            for (int i = (token + 1) % N;; i = (i + 1) % N) {
                if (i == token)
                    break;
                process[token].state[i] = -1;
            }
        }
        
        // atualiza o proprio state, apenas para controle do diagnostico, esse valor
        // nao e usado para transferencias
        ++process[token].state[token];
        {% endhighlight %}
        <li>Melhorias de comentários e logs.</li>
    </ol>
    <h2>Execuç<li>Uma função para criação do evento (falha ou recuperação), onde para falhas o vetor de estados do processo em que o
        evento ocorre é reinicializado. O próprio estado do processo é utilizado para verificação do diagnóstico. Ele não é
        utilizado para transferências:</li>
    {% highlight c %}
    event = (Event *)malloc(sizeof(Event));
    event->id = ++id_cont;
    event->e_round = sim_round;
    event->e_time = time();
    event->proc = token;
    event->type = type;
    event->n_tests = 0;
    event->diag = false;
    event->latency = 0;
    insert_array(event_array, event);

    // se falha, reseta o vetor de estados pois é falha crash
    if (type == 1) {
        for (int i = (token + 1) % N;; i = (i + 1) % N) {
        if (i == token)
            break;
       . Os símbolos de raio indicam falha, e os de coração representam recuperação.</p>
    <h3>Teste 1</h3>
    <p>Este teste foi executado para 3 processos, com o tempo máximo de simulação de 100. Os eventos agendados foram:</p>
    <ol>
        <li>Falha do processo 1 no tempo 31</li>
        <li>Recuperação do processo 1 no tempo 61</li>
    </ol>
    <p>O estado de cada processo durante as rodadas pode ser visualizado na imagem abaixo:</p>
    <img src="./img/teste1.png" alt="teste 1">
    <p>O log deste teste pode ser visualizado abaixo:</p>
{% highlight plaintext %}
Este programa foi executado para N=3 processos
O tempo maximo de simulacao e de 100

******************************************
Iniciando round de testes 1

==========================================
Iniciando testes do processo 0
State do processo 0: 0[0] 1[-1] 2[-1] 
Processo 0 testou processo 1 no tempo 30.0: correto
State[1] atualizado para 0
Atualizando state do processo 0 com o state do processo 1
State do processo 1: 0[-1] 1[0] 2[-1] 
Nenhuma transferencia realizada
State do processo 0: 0[0] 1[0] 2[-1] 
==========================================

==========================================
Iniciando testes do processo 1
State do processo 1: 0[-1] 1[0] 2[-1] 
Processo 1 testou processo 2 no tempo 30.0: correto
State[2] atualizado para 0
Atualizando state do processo 1 com o state do processo 2
State do processo 2: 0[-1] 1[-1] 2[0] 
Nenhuma transferencia realizada
State do processo 1: 0[-1] 1[0] 2[0] 
==========================================

==========================================
Iniciando testes do processo 2
State do processo 2: 0[-1] 1[-1] 2[0] 
Processo 2 testou processo 0 no tempo 30.0: correto
State[0] atualizado para 0
Atualizando state do processo 2 com o state do processo 0
State do processo 0: 0[0] 1[0] 2[-1] 
Novidade encontrada, transferindo state[1]...
State[1] atualizado para 0
State do processo 2: 0[0] 1[0] 2[0] 
==========================================

--> Event[1]: Processo 1 falhou no tempo 31.0

******************************************
Iniciando round de testes 2

==========================================
Iniciando testes do processo 0
State do processo 0: 0[0] 1[0] 2[-1] 
Processo 0 testou processo 1 no tempo 60.0: falho
State[1] atualizado para 1
Event[1] testado pelo processo 0
Event[1] descoberto pelo processo 0
Processo 0 testou processo 2 no tempo 60.0: correto
State[2] atualizado para 0
Atualizando state do processo 0 com o state do processo 2
State do processo 2: 0[0] 1[0] 2[0] 
Nenhuma transferencia realizada
State do processo 0: 0[0] 1[1] 2[0] 
==========================================

==========================================
Iniciando testes do processo 2
State do processo 2: 0[0] 1[0] 2[0] 
Processo 2 testou processo 0 no tempo 60.0: correto
Atualizando state do processo 2 com o state do processo 0
State do processo 0: 0[0] 1[1] 2[0] 
Novidade encontrada, transferindo state[1]...
State[1] atualizado para 1
Event[1] descoberto pelo processo 2
--> Diagnostico do evento 1 completo
State do processo 2: 0[0] 1[1] 2[0] 
==========================================

--> Event[2]: Processo 1 recuperou no tempo 61.0

******************************************
Iniciando round de testes 3

==========================================
Iniciando testes do processo 0
State do processo 0: 0[0] 1[1] 2[0] 
Processo 0 testou processo 1 no tempo 90.0: correto
State[1] atualizado para 2
Event[2] testado pelo processo 0
Event[2] descoberto pelo processo 0
Atualizando state do processo 0 com o state do processo 1
State do processo 1: 0[-1] 1[2] 2[-1] 
Nenhuma transferencia realizada
State do processo 0: 0[0] 1[2] 2[0] 
==========================================

==========================================
Iniciando testes do processo 2
State do processo 2: 0[0] 1[1] 2[0] 
Processo 2 testou processo 0 no tempo 90.0: correto
Atualizando state do processo 2 com o state do processo 0
State do processo 0: 0[0] 1[2] 2[0] 
Novidade encontrada, transferindo state[1]...
State[1] atualizado para 2
Event[2] descoberto pelo processo 2
--> Diagnostico do evento 2 completo
State do processo 2: 0[0] 1[2] 2[0] 
==========================================

==========================================
Iniciando testes do processo 1
State do processo 1: 0[-1] 1[2] 2[-1] 
Processo 1 testou processo 2 no tempo 91.0: correto
State[2] atualizado para 0
Atualizando state do processo 1 com o state do processo 2
State do processo 2: 0[0] 1[2] 2[0] 
Novidade encontrada, transferindo state[0]...
State[0] atualizado para 0
State do processo 1: 0[0] 1[2] 2[0] 
==========================================

******************************************
Iniciando round de testes 4

==========================================
Iniciando testes do processo 0
State do processo 0: 0[0] 1[2] 2[0] 
Processo 0 testou processo 1 no tempo 120.0: correto
Atualizando state do processo 0 com o state do processo 1
State do processo 1: 0[0] 1[2] 2[0] 
Nenhuma transferencia realizada
State do processo 0: 0[0] 1[2] 2[0] 
==========================================

******************************************
Simulacao encerrada

==========================================

Eventos durante a simulacao:
Event[1]: FALHA | round 1 | tempo 031.0 | processo 1 | numero de testes de 1 | latencia de 1
Event[2]: RECUP | round 2 | tempo 061.0 | processo 1 | numero de testes de 1 | latencia de 1

==========================================
Programa finalizado com sucesso
Autor: Giovanni Rosa :)
==========================================
{% endhighlight %}
    </body>